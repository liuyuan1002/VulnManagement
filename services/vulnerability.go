package services

import (
	"errors"
	"time"
	Init "vulnmain/Init"
	"vulnmain/models"
)

type VulnService struct{}

type VulnCreateRequest struct {
	Title       string  `json:"title" binding:"required"`
	Description string  `json:"description"`
	VulnType    string  `json:"vuln_type" binding:"required"`
	Severity    string  `json:"severity" binding:"required"`
	Source      string  `json:"source"`
	CVEID       string  `json:"cve_id"`
	CNNVDID     string  `json:"cnnvd_id"`
	CVSSScore   float64 `json:"cvss_score"`
	POC         string  `json:"poc"`
	Solution    string  `json:"solution"`
	References  string  `json:"references"`
	AssetID     uint    `json:"asset_id" binding:"required"`
	ProjectID   uint    `json:"project_id" binding:"required"`
	AssigneeID  *uint   `json:"assignee_id"`
	Tags        string  `json:"tags"`
}

type VulnUpdateRequest struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	VulnType    string `json:"vuln_type"`
	Severity    string `json:"severity"`
	Status      string `json:"status"`
	POC         string `json:"poc"`
	Solution    string `json:"solution"`
	References  string `json:"references"`
	AssigneeID  *uint  `json:"assignee_id"`
	Tags        string `json:"tags"`
}

type VulnListRequest struct {
	Page       int    `form:"page" binding:"min=1"`
	PageSize   int    `form:"page_size" binding:"min=1,max=100"`
	Keyword    string `form:"keyword"`
	Title      string `form:"title"`
	VulnType   string `form:"vuln_type"`
	Severity   string `form:"severity"`
	Status     string `form:"status"`
	Source     string `form:"source"`
	AssetID    *uint  `form:"asset_id"`
	ProjectID  *uint  `form:"project_id"`
	ReporterID *uint  `form:"reporter_id"`
	AssigneeID *uint  `form:"assignee_id"`
	// 权限控制字段
	CurrentUserID   uint   `form:"-"`
	CurrentUserRole string `form:"-"`
}

type VulnListResponse struct {
	Vulns           []models.Vulnerability `json:"vulns"`
	Vulnerabilities []models.Vulnerability `json:"vulnerabilities"`
	Total           int64                  `json:"total"`
	Page            int                    `json:"page"`
	PageSize        int                    `json:"page_size"`
	CurrentPage     int                    `json:"current_page"`
	TotalPages      int                    `json:"total_pages"`
}

type AuditRequest struct {
	Status     string  `json:"status" binding:"required"`
	Comment    string  `json:"comment"`
	Severity   string  `json:"severity"`
	CvssScore  float64 `json:"cvss_score"`
	AssigneeID *uint   `json:"assignee_id"`
}

// CreateVuln 创建漏洞
func (s *VulnService) CreateVuln(req *VulnCreateRequest, reporterID uint) (*models.Vulnerability, error) {
	db := Init.GetDB()

	// 验证资产是否存在
	var asset models.Asset
	if err := db.Where("id = ?", req.AssetID).First(&asset).Error; err != nil {
		return nil, errors.New("资产不存在")
	}

	// 验证分配人是否存在(如果指定)
	if req.AssigneeID != nil {
		var assignee models.User
		if err := db.Where("id = ?", *req.AssigneeID).First(&assignee).Error; err != nil {
			return nil, errors.New("指定的分配人不存在")
		}
	}

	vuln := models.Vulnerability{
		Title:       req.Title,
		Description: req.Description,
		VulnType:    req.VulnType,
		Severity:    req.Severity,
		Status:      "pending",
		CVEID:       req.CVEID,
		ProjectID:   req.ProjectID,
		AssetID:     req.AssetID,
		ReporterID:  reporterID,
		AssigneeID:  req.AssigneeID,
		SubmittedAt: time.Now().Truncate(time.Second), // 设置提交时间，精确到秒
		Tags:        req.Tags,
	}

	if err := db.Create(&vuln).Error; err != nil {
		return nil, errors.New("创建漏洞失败")
	}

	// 创建时间线记录
	s.addTimeline(vuln.ID, reporterID, "created", "漏洞已创建")

	// 如果指定了分配人，创建分配记录
	if req.AssigneeID != nil {
		s.addTimeline(vuln.ID, reporterID, "assigned", "漏洞已分配")
	}

	// 重新查询漏洞信息(包含关联数据)
	db.Preload("Asset").Preload("Project").Preload("Reporter").Preload("Assignee").Where("id = ?", vuln.ID).First(&vuln)

	// 更新项目统计信息
	if req.ProjectID != 0 {
		projectService := &ProjectService{}
		if err := projectService.UpdateProjectStats(req.ProjectID); err != nil {
			// 统计更新失败不影响漏洞创建，只记录错误
			// 可以考虑添加日志记录
		}
	}

	return &vuln, nil
}

// GetVulnByID 根据ID获取漏洞
func (s *VulnService) GetVulnByID(vulnID uint, userID uint, userRole string) (*models.Vulnerability, error) {
	db := Init.GetDB()

	var vuln models.Vulnerability
	if err := db.Preload("Asset").Preload("Project").Preload("Reporter").Preload("Assignee").
		Preload("Fixer").Preload("Retester").Preload("Attachments").Preload("Comments.User").
		Preload("Timeline.User").Where("id = ?", vulnID).First(&vuln).Error; err != nil {
		return nil, errors.New("漏洞不存在")
	}

	// 基于角色的权限控制
	canAccess := false
	switch userRole {
	case "super_admin":
		// 超级管理员能看到所有漏洞
		canAccess = true
	case "security_engineer":
		// 安全工程师可以看到自己创建的漏洞，或者自己参与项目的漏洞
		if vuln.ReporterID == userID {
			canAccess = true
		} else {
			// 检查是否是项目成员
			var memberCount int64
			db.Model(&models.ProjectMember{}).Where("project_id = ? AND user_id = ?", vuln.ProjectID, userID).Count(&memberCount)
			if memberCount > 0 {
				canAccess = true
			}
		}
	case "dev_engineer":
		// 研发工程师可以看到分配给自己的漏洞，或者自己参与项目的漏洞
		if vuln.AssigneeID != nil && *vuln.AssigneeID == userID {
			canAccess = true
		} else {
			// 检查是否是项目成员
			var memberCount int64
			db.Model(&models.ProjectMember{}).Where("project_id = ? AND user_id = ?", vuln.ProjectID, userID).Count(&memberCount)
			if memberCount > 0 {
				canAccess = true
			}
		}
	}

	if !canAccess {
		return nil, errors.New("漏洞不存在")
	}

	return &vuln, nil
}

// UpdateVuln 更新漏洞信息
func (s *VulnService) UpdateVuln(vulnID uint, req *VulnUpdateRequest, userID uint, userRole string) (*models.Vulnerability, error) {
	db := Init.GetDB()

	var vuln models.Vulnerability
	if err := db.Where("id = ?", vulnID).First(&vuln).Error; err != nil {
		return nil, errors.New("漏洞不存在")
	}

	// 基于角色的权限控制和字段更新
	switch userRole {
	case "super_admin":
		// 超级管理员可以更新所有字段
		if req.Title != "" {
			vuln.Title = req.Title
		}
		if req.Description != "" {
			vuln.Description = req.Description
		}
		if req.VulnType != "" {
			vuln.VulnType = req.VulnType
		}
		if req.Severity != "" {
			vuln.Severity = req.Severity
		}
		if req.Status != "" {
			vuln.Status = req.Status
		}
		if req.Tags != "" {
			vuln.Tags = req.Tags
		}

	case "security_engineer":
		// 安全工程师只能更新自己创建的漏洞或项目内的漏洞
		if vuln.ReporterID != userID {
			// 检查是否是项目成员
			var memberCount int64
			db.Model(&models.ProjectMember{}).Where("project_id = ? AND user_id = ?", vuln.ProjectID, userID).Count(&memberCount)
			if memberCount == 0 {
				return nil, errors.New("无权限编辑此漏洞")
			}
		}

		// 安全工程师可以更新大部分字段
		if req.Title != "" {
			vuln.Title = req.Title
		}
		if req.Description != "" {
			vuln.Description = req.Description
		}
		if req.VulnType != "" {
			vuln.VulnType = req.VulnType
		}
		if req.Severity != "" {
			vuln.Severity = req.Severity
		}
		if req.Status != "" {
			vuln.Status = req.Status
		}
		if req.Tags != "" {
			vuln.Tags = req.Tags
		}

	case "dev_engineer":
		// 研发工程师只能更新分配给自己的漏洞的状态
		if vuln.AssigneeID == nil || *vuln.AssigneeID != userID {
			// 检查是否是项目成员
			var memberCount int64
			db.Model(&models.ProjectMember{}).Where("project_id = ? AND user_id = ?", vuln.ProjectID, userID).Count(&memberCount)
			if memberCount == 0 {
				return nil, errors.New("无权限编辑此漏洞")
			}
		}

		// 研发工程师只能更新状态
		if req.Status != "" {
			// 验证状态是否有效
			validStatuses := []string{"unfixed", "fixing", "fixed"}
			isValidStatus := false
			for _, status := range validStatuses {
				if req.Status == status {
					isValidStatus = true
					break
				}
			}
			if !isValidStatus {
				return nil, errors.New("研发工程师只能将状态设置为: 未修复、修复中、已修复")
			}

			vuln.Status = req.Status

			// 记录状态变更时间
			now := time.Now().Truncate(time.Second)
			if req.Status == "fixing" && vuln.Status != "fixing" {
				vuln.FixStartedAt = &now
			} else if req.Status == "fixed" && vuln.Status != "fixed" {
				vuln.FixedAt = &now
				vuln.FixedBy = &userID
			}
		}

	default:
		return nil, errors.New("无权限编辑漏洞")
	}

	// 处理分配人变更（仅管理员和安全工程师可以修改）
	if (userRole == "super_admin" || userRole == "security_engineer") && req.AssigneeID != nil && (vuln.AssigneeID == nil || *vuln.AssigneeID != *req.AssigneeID) {
		if *req.AssigneeID != 0 {
			// 验证分配人是否存在
			var assignee models.User
			if err := db.Where("id = ?", *req.AssigneeID).First(&assignee).Error; err != nil {
				return nil, errors.New("指定的分配人不存在")
			}
			vuln.AssigneeID = req.AssigneeID
			s.addTimeline(vulnID, userID, "assigned", "漏洞重新分配")
		} else {
			vuln.AssigneeID = nil
			s.addTimeline(vulnID, userID, "unassigned", "取消漏洞分配")
		}
	}

	if err := db.Save(&vuln).Error; err != nil {
		return nil, errors.New("更新漏洞失败")
	}

	s.addTimeline(vulnID, userID, "updated", "漏洞信息已更新")

	// 重新查询漏洞信息
	db.Preload("Asset").Preload("Project").Preload("Reporter").Preload("Assignee").Where("id = ?", vuln.ID).First(&vuln)

	// 更新项目统计信息
	if vuln.ProjectID != 0 {
		projectService := &ProjectService{}
		if err := projectService.UpdateProjectStats(vuln.ProjectID); err != nil {
			// 统计更新失败不影响漏洞更新，只记录错误
			// 可以考虑添加日志记录
		}
	}

	return &vuln, nil
}

// DeleteVuln 删除漏洞(软删除)
func (s *VulnService) DeleteVuln(vulnID uint, userID uint) error {
	db := Init.GetDB()

	var vuln models.Vulnerability
	if err := db.Where("id = ?", vulnID).First(&vuln).Error; err != nil {
		return errors.New("漏洞不存在")
	}

	// 记录项目ID用于后续更新统计
	projectID := vuln.ProjectID

	if err := db.Delete(&vuln).Error; err != nil {
		return errors.New("删除漏洞失败")
	}

	// 记录时间线
	s.addTimeline(vulnID, userID, "deleted", "漏洞已删除")

	// 更新项目统计信息
	if projectID != 0 {
		projectService := &ProjectService{}
		if err := projectService.UpdateProjectStats(projectID); err != nil {
			// 统计更新失败不影响漏洞删除，只记录错误
			// 可以考虑添加日志记录
		}
	}

	return nil
}

// GetVulnList 获取漏洞列表
func (s *VulnService) GetVulnList(req *VulnListRequest) (*VulnListResponse, error) {
	db := Init.GetDB()

	// 设置默认值
	if req.Page <= 0 {
		req.Page = 1
	}
	if req.PageSize <= 0 {
		req.PageSize = 10
	}

	query := db.Model(&models.Vulnerability{}).Preload("Asset").Preload("Project").Preload("Reporter").Preload("Assignee")

	// 基于角色的权限控制
	// 如果是查询特定项目的漏洞，需要先检查用户是否是项目成员
	if req.ProjectID != nil {
		// 检查用户是否是项目成员（管理员和项目成员都可以查看）
		if req.CurrentUserRole != "super_admin" {
			var memberCount int64
			db.Model(&models.ProjectMember{}).Where("project_id = ? AND user_id = ?", *req.ProjectID, req.CurrentUserID).Count(&memberCount)
			if memberCount == 0 {
				// 用户不是项目成员，不能查看项目漏洞
				return &VulnListResponse{
					Vulns:           []models.Vulnerability{},
					Vulnerabilities: []models.Vulnerability{},
					Total:           0,
					Page:            req.Page,
					PageSize:        req.PageSize,
				}, nil
			}
		}
		// 如果用户是项目成员或管理员，可以查看项目内所有漏洞，不添加额外的用户限制
	} else {
		// 查询全局漏洞列表时，应用原有的权限控制
		switch req.CurrentUserRole {
		case "security_engineer":
			// 安全工程师只能看到自己创建的漏洞
			query = query.Where("reporter_id = ?", req.CurrentUserID)
		case "dev_engineer":
			// 研发工程师只能看到分配给自己的漏洞
			query = query.Where("assignee_id = ?", req.CurrentUserID)
		case "super_admin":
			// 超级管理员能看到所有漏洞，不添加额外限制
		default:
			// 其他角色不能查看漏洞列表
			return &VulnListResponse{
				Vulns:           []models.Vulnerability{},
				Vulnerabilities: []models.Vulnerability{},
				Total:           0,
				Page:            req.Page,
				PageSize:        req.PageSize,
			}, nil
		}
	}

	// 添加过滤条件
	if req.Keyword != "" {
		// 支持关键词搜索，在标题、描述、CVE ID中搜索
		query = query.Where("title LIKE ? OR description LIKE ? OR cve_id LIKE ?",
			"%"+req.Keyword+"%", "%"+req.Keyword+"%", "%"+req.Keyword+"%")
	}
	if req.Title != "" {
		query = query.Where("title LIKE ?", "%"+req.Title+"%")
	}
	if req.VulnType != "" {
		query = query.Where("vuln_type = ?", req.VulnType)
	}
	if req.Severity != "" {
		query = query.Where("severity = ?", req.Severity)
	}
	if req.Status != "" {
		query = query.Where("status = ?", req.Status)
	}
	if req.Source != "" {
		query = query.Where("source = ?", req.Source)
	}
	if req.AssetID != nil {
		query = query.Where("asset_id = ?", *req.AssetID)
	}
	if req.ProjectID != nil {
		query = query.Where("project_id = ?", *req.ProjectID)
	}
	if req.ReporterID != nil {
		query = query.Where("reporter_id = ?", *req.ReporterID)
	}
	if req.AssigneeID != nil {
		query = query.Where("assignee_id = ?", *req.AssigneeID)
	}

	// 获取总数
	var total int64
	query.Count(&total)

	// 分页查询
	var vulns []models.Vulnerability
	offset := (req.Page - 1) * req.PageSize
	if err := query.Offset(offset).Limit(req.PageSize).Order("created_at DESC").Find(&vulns).Error; err != nil {
		return nil, errors.New("查询漏洞列表失败")
	}

	// 计算总页数
	totalPages := int((total + int64(req.PageSize) - 1) / int64(req.PageSize))

	return &VulnListResponse{
		Vulns:           vulns,
		Vulnerabilities: vulns, // 为前端兼容性提供同样的数据
		Total:           total,
		Page:            req.Page,
		PageSize:        req.PageSize,
		CurrentPage:     req.Page,
		TotalPages:      totalPages,
	}, nil
}

// AuditVuln 审核漏洞
func (s *VulnService) AuditVuln(vulnID uint, req *AuditRequest, userID uint) error {
	db := Init.GetDB()

	var vuln models.Vulnerability
	if err := db.Where("id = ?", vulnID).First(&vuln).Error; err != nil {
		return errors.New("漏洞不存在")
	}

	if vuln.Status != "pending" {
		return errors.New("只能审核待确认的漏洞")
	}

	if req.Status != "confirmed" && req.Status != "rejected" {
		return errors.New("无效的审核状态")
	}

	vuln.Status = req.Status

	// 更新其他审核信息
	if req.Severity != "" {
		vuln.Severity = req.Severity
	}

	if req.AssigneeID != nil {
		vuln.AssigneeID = req.AssigneeID
	}

	if err := db.Save(&vuln).Error; err != nil {
		return errors.New("审核漏洞失败")
	}

	action := "confirmed"
	description := "漏洞已确认"
	if req.Status == "rejected" {
		action = "rejected"
		description = "漏洞已拒绝"
	}

	s.addTimeline(vulnID, userID, action, description)

	return nil
}

// FixVuln 标记漏洞为已修复
func (s *VulnService) FixVuln(vulnID uint, userID uint) error {
	db := Init.GetDB()

	var vuln models.Vulnerability
	if err := db.Where("id = ?", vulnID).First(&vuln).Error; err != nil {
		return errors.New("漏洞不存在")
	}

	if vuln.Status != "confirmed" && vuln.Status != "fixing" {
		return errors.New("只能修复已确认的漏洞")
	}

	vuln.Status = "fixed"
	vuln.FixedBy = &userID
	now := time.Now().Truncate(time.Second)
	vuln.FixedAt = &now

	if err := db.Save(&vuln).Error; err != nil {
		return errors.New("标记修复失败")
	}

	s.addTimeline(vulnID, userID, "fixed", "漏洞已修复")

	return nil
}

// RetestVuln 复测漏洞
func (s *VulnService) RetestVuln(vulnID uint, result string, userID uint) error {
	db := Init.GetDB()

	var vuln models.Vulnerability
	if err := db.Where("id = ?", vulnID).First(&vuln).Error; err != nil {
		return errors.New("漏洞不存在")
	}

	if vuln.Status != "fixed" {
		return errors.New("只能复测已修复的漏洞")
	}

	if result != "passed" && result != "failed" {
		return errors.New("无效的复测结果")
	}

	if result == "passed" {
		vuln.Status = "closed"
	} else {
		vuln.Status = "reopened"
	}

	if err := db.Save(&vuln).Error; err != nil {
		return errors.New("复测失败")
	}

	action := "retested_passed"
	description := "复测通过，漏洞已关闭"
	if result == "failed" {
		action = "retested_failed"
		description = "复测失败，漏洞重新开放"
	}

	s.addTimeline(vulnID, userID, action, description)

	return nil
}

// AddComment 添加评论
func (s *VulnService) AddComment(vulnID uint, content string, userID uint) (*models.VulnComment, error) {
	db := Init.GetDB()

	// 验证漏洞是否存在
	var vuln models.Vulnerability
	if err := db.Where("id = ?", vulnID).First(&vuln).Error; err != nil {
		return nil, errors.New("漏洞不存在")
	}

	comment := models.VulnComment{
		VulnID:  vulnID,
		Content: content,
		UserID:  userID,
	}

	if err := db.Create(&comment).Error; err != nil {
		return nil, errors.New("添加评论失败")
	}

	// 重新查询评论信息(包含用户信息)
	db.Preload("User").Where("id = ?", comment.ID).First(&comment)

	return &comment, nil
}

// GetVulnStats 获取漏洞统计信息
func (s *VulnService) GetVulnStats() (map[string]interface{}, error) {
	db := Init.GetDB()

	var totalVulns int64
	var pendingVulns int64
	var confirmedVulns int64
	var fixedVulns int64
	var closedVulns int64

	db.Model(&models.Vulnerability{}).Count(&totalVulns)
	db.Model(&models.Vulnerability{}).Where("status = ?", "pending").Count(&pendingVulns)
	db.Model(&models.Vulnerability{}).Where("status = ?", "confirmed").Count(&confirmedVulns)
	db.Model(&models.Vulnerability{}).Where("status = ?", "fixed").Count(&fixedVulns)
	db.Model(&models.Vulnerability{}).Where("status = ?", "closed").Count(&closedVulns)

	// 按严重程度统计
	var severityStats []struct {
		Severity string `json:"severity"`
		Count    int64  `json:"count"`
	}
	db.Model(&models.Vulnerability{}).Select("severity, COUNT(*) as count").Group("severity").Scan(&severityStats)

	// 按类型统计
	var typeStats []struct {
		VulnType string `json:"vuln_type"`
		Count    int64  `json:"count"`
	}
	db.Model(&models.Vulnerability{}).Select("vuln_type, COUNT(*) as count").Group("vuln_type").Scan(&typeStats)

	return map[string]interface{}{
		"total_vulns":     totalVulns,
		"pending_vulns":   pendingVulns,
		"confirmed_vulns": confirmedVulns,
		"fixed_vulns":     fixedVulns,
		"closed_vulns":    closedVulns,
		"severity_stats":  severityStats,
		"type_stats":      typeStats,
	}, nil
}

// addTimeline 添加时间线记录
func (s *VulnService) addTimeline(vulnID uint, userID uint, action string, description string) {
	db := Init.GetDB()

	timeline := models.VulnTimeline{
		VulnID:      vulnID,
		Action:      action,
		Description: description,
		UserID:      userID,
	}

	db.Create(&timeline)
}
